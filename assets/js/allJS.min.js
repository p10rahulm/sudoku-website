class SudokuClass{constructor(e){this.sudokuInputArray=e,this.workElemArray=new Array(81).fill(511),this.workElemIndicesByLength=[0].concat(Array.from(Array(81),(e,o)=>o+900)),this.done=!1,this.toProcess=[],this.contradiction=!1,this.numProcessed=0}}class GameClass{constructor(){this.elemIndices={};for(let e=0;e<81;e++){const o=~~(e/9),n=e%9,t=3*~~(o/3)+~~(n/3);this.elemIndices[e]=[o,n,t]}this.indicesinRows=[],this.indicesinCols=[],this.indicesinBoxes=[];for(let e=0;e<9;e++)this.indicesinRows[e]=[],this.indicesinCols[e]=[],this.indicesinBoxes[e]=[];for(let e=0;e<81;e++)this.indicesinRows[this.elemIndices[e][0]].push(e),this.indicesinCols[this.elemIndices[e][1]].push(e),this.indicesinBoxes[this.elemIndices[e][2]].push(e)}}class Iteration{constructor(e){this.startTime=performance.now(),this.stackdepth=0,this.solutionFound=!1,this.leastIndexIterationtimeTaken=0,this.copytimetaken=0,this.copyworkElemArrayTT=0,this.copyworkElemIndicesByLengthTT=0,this.copyprocessedTT=0,this.copyinitTT=0,this.copycontradictionTT=0,this.copyTotalTT=0,this.updateWEIBLTimeTaken=0,this.updateAdditionForElemsTimeTaken=0,this.addinputSudokuTT=0,this.AddInputTT=0,this.skpushTT=0,this.flTT=0,this.poppingTT=0,this.afterIsDoneTT=0,this.totalRunDFSTT=0,this.nflTT=0,this.AddInputDirectLoopTT=0,this.numIterations=0,this.numLoops=0,this.solutionFound=0,this.solvedSudoku=e}}function start(){drawFirstSudoku()}function checkInputDiv(e){clearOptionsDiv(),checkInput(e.target.id,e.target.value)}function buildSudoku(){Sudoku=new SudokuClass([]),Game=new GameClass,startIter=new Iteration(Sudoku)}function drawFirstSudoku(){const e=document.getElementById("sudoku-box");drawSudoku(Sudoku,e,"input"),setAttributes(e.getElementsByTagName("input"))}function setAttributes(e){for(let o=0;o<e.length;o++){const n=e[o];n.id=o,n.addEventListener("click",createOptions,!1),n.addEventListener("change",checkInputDiv,!1),n.setAttribute("size",1),n.setAttribute("maxlength",1),n.setAttribute("autocomplete","off")}}function createNewSudoku(e){const o=new Array(81),n={};for(let e=1;e<=9;e++)n[e]=new Set;for(let t=0;t<81;t++)0==e[t]&&(o[t]=511,n[9].add(t));return Sudoku.sudokuInputArray=e,Sudoku.workElemArray=o,Sudoku.workElemIndicesByLength=n,Sudoku.done=!1,Sudoku.toProcess=[],Sudoku.contradiction=!1,Sudoku}function copySudokuHeap(e,o){const n=performance.now(),t=performance.now(),r={};o.copyinitTT+=performance.now()-t;const i=performance.now();r.workElemArray=e.workElemArray.slice(0),o.copyworkElemArrayTT+=performance.now()-i;const s=performance.now();r.workElemIndicesByLength=e.workElemIndicesByLength.slice(0),o.copyworkElemIndicesByLengthTT+=performance.now()-s;const u=performance.now();r.toProcess=e.toProcess.slice(0),o.copyprocessedTT+=performance.now()-u;const d=performance.now();return r.contradiction=e.contradiction,r.numProcessed=e.numProcessed,o.copycontradictionTT+=performance.now()-d,o.copyTotalTT+=performance.now()-n,r}function copySudoku(e){copyTotalTS=performance.now(),copyinitTS=performance.now();const o={};copyinitTT+=performance.now()-copyinitTS,copyworkElemArrayTS=performance.now(),o.workElemArray=e.workElemArray.slice(0),copyworkElemArrayTT+=performance.now()-copyworkElemArrayTS,copyworkElemIndicesByLengthTS=performance.now(),o.workElemIndicesByLength={};for(let n=1;n<10;n++)o.workElemIndicesByLength[n]=new Set(e.workElemIndicesByLength[n]);return copyworkElemIndicesByLengthTT+=performance.now()-copyworkElemIndicesByLengthTS,copyprocessedTS=performance.now(),o.toProcess=e.toProcess.slice(0),copyprocessedTT+=performance.now()-copyprocessedTS,copycontradictionTS=performance.now(),o.contradiction=e.contradiction,copycontradictionTT+=performance.now()-copycontradictionTS,copyTotalTT+=performance.now()-copyTotalTS,o}function dfsCreatorSudoku(){let e=new Iteration(Sudoku);const o=copySudokuHeap(Sudoku,e),n=[];n.push(o),e=runDFSSudokuIterativeHeap(n,e);let t=0;document.getElementById("verbose-time-results-option").checked&&(t=1);const r=document.getElementById("num-iterations-option").value;if(e.solutionFound){for(let o=0;o<r;o++){const n=new Iteration(Sudoku),t=copySudokuHeap(Sudoku,e),r=[];r.push(t),runDFSSudokuIterativeHeap(r,n),updateIter(e,n,o+2)}console.log("iteration=",e),doFinishedProcessing(e.solvedSudoku,e,1,0,t)}else doFinishedProcessing(Sudoku,e,0,0,t)}function updateIter(e,o,n){e.numIterations+=1,e.stackdepth=(n-1)*e.stackdepth/n+1/n*o.stackdepth,e.leastIndexIterationtimeTaken=(n-1)*e.leastIndexIterationtimeTaken/n+1/n*o.leastIndexIterationtimeTaken,e.copytimetaken=(n-1)*e.copytimetaken/n+1/n*o.copytimetaken,e.copyworkElemArrayTT=(n-1)*e.copyworkElemArrayTT/n+1/n*o.copyworkElemArrayTT,e.copyworkElemIndicesByLengthTT=(n-1)*e.copyworkElemIndicesByLengthTT/n+1/n*o.copyworkElemIndicesByLengthTT,e.copyprocessedTT=(n-1)*e.copyprocessedTT/n+1/n*o.copyprocessedTT,e.copyinitTT=(n-1)*e.copyinitTT/n+1/n*o.copyinitTT,e.copycontradictionTT=(n-1)*e.copycontradictionTT/n+1/n*o.copycontradictionTT,e.copyTotalTT=(n-1)*e.copyTotalTT/n+1/n*o.copyTotalTT,e.updateWEIBLTimeTaken=(n-1)*e.updateWEIBLTimeTaken/n+1/n*o.updateWEIBLTimeTaken,e.updateAdditionForElemsTimeTaken=(n-1)*e.updateAdditionForElemsTimeTaken/n+1/n*o.updateAdditionForElemsTimeTaken,e.addinputSudokuTT=(n-1)*e.addinputSudokuTT/n+1/n*o.addinputSudokuTT,e.AddInputTT=(n-1)*e.AddInputTT/n+1/n*o.AddInputTT,e.skpushTT=(n-1)*e.skpushTT/n+1/n*o.skpushTT,e.flTT=(n-1)*e.flTT/n+1/n*o.flTT,e.poppingTT=(n-1)*e.poppingTT/n+1/n*o.poppingTT,e.afterIsDoneTT=(n-1)*e.afterIsDoneTT/n+1/n*o.afterIsDoneTT,e.totalRunDFSTT=(n-1)*e.totalRunDFSTT/n+1/n*o.totalRunDFSTT,e.nflTT=(n-1)*e.nflTT/n+1/n*o.nflTT,e.AddInputDirectLoopTT=(n-1)*e.AddInputDirectLoopTT/n+1/n*o.AddInputDirectLoopTT,e.numLoops=((n-1)*e.numLoops+o.numLoops)/n}function runDFSSudokuRecursive(e){totalRunDFSTS=performance.now(),nflTS=performance.now(),poppingTS=performance.now();const o=e.pop();if(poppingTT+=performance.now()-poppingTS,solutionFound)return;if(isSudokuDone(o)){afterIsDoneTS=performance.now(),solutionFound=!0;const e=performance.now()-startTime,n=document.getElementById("output-boxes");removeChildren(n);const t=document.createElement("div");t.innerHTML="Solution: Done in ",t.className="output-heading",n.appendChild(t);const r=document.createElement("div"),i="solved in "+e+"ms.<br>totalRunDFSTT = "+totalRunDFSTT+"ms<br>non-for loop time taken = "+nflTT+"ms<br>for loop time taken = "+flTT+"ms<br><br><br>Non-forloop<br>least Index time taken = "+leastIndexIterationtimeTaken+"ms.<br>afterIsDoneTT = "+afterIsDoneTT+"ms<br>sudokuHolder popping time taken = "+poppingTT+"ms<br><br>Forloop<br>copy time taken = "+copytimetaken+"ms.<br>AddInputTT time taken = "+AddInputTT+"ms.<br>sudokuHolder push time taken = "+skpushTT+"ms.<br><br>Other pages:Deepdive<br>copy function: total time taken = "+copyTotalTT+"ms.<br>copy function: initialize time taken = "+copyinitTT+"ms.<br>copy function: workElemArray time taken = "+copyworkElemArrayTT+"ms.<br>copy function: workElemIndicesByLength time taken = "+copyworkElemIndicesByLengthTT+"ms.<br>copy function: processed time taken = "+copyprocessedTT+"ms.<br>copy function: contradiction time taken = "+copycontradictionTT+"ms.<br>updateWEIBL Function time taken = "+updateWEIBLTimeTaken+"ms.<br>function updateAdditionForElems time taken = "+updateAdditionForElemsTimeTaken+"ms.<br>function: addInputSudoku time taken = "+addinputSudokuTT+"ms.<br>";return r.innerHTML=i,r.className="output-heading",n.appendChild(r),console.log("sudoku done. sudoku = ",o),drawSudoku(o,n,"div"),afterIsDoneTT+=performance.now()-afterIsDoneTS,o}leastIndexIterationTS=performance.now();o.workElemIndicesByLength;let n=0;for(let e=1;e<=9&&!n;e++)0!==o.workElemIndicesByLength[e].size&&(n=e);const t=o.workElemIndicesByLength[n].values().next().value,r=getAllowedNumbersforIndex(t,o);leastIndexIterationtimeTaken+=performance.now()-leastIndexIterationTS,nflTT+=performance.now()-nflTS,flTS=performance.now();for(let n=0;n<r.length&&!solutionFound;n++){const i=r[n];copyTimeStart=performance.now();const s=copySudoku(o);copytimetaken+=performance.now()-copyTimeStart,AddInputTS=performance.now(),addInputSudoku(s,t,i,1),AddInputTT+=performance.now()-AddInputTS,skpushTS=performance.now(),s.contradiction||e.push(s),skpushTT+=performance.now()-skpushTS}flTT+=performance.now()-flTS,totalRunDFSTT+=performance.now()-totalRunDFSTS,runDFSSudokuRecursive(e)}function runDFSSudokuIterativeHeap(e,o){const n=performance.now();for(;0!=e.length&&!o.solutionFound;){o.numLoops++;const t=performance.now(),r=performance.now(),i=e.pop();if(o.poppingTT+=performance.now()-r,isSudokuDoneHeap(i,o))return o.totalRunDFSTT=performance.now()-n,o.solutionFound=!0,o.solvedSudoku=i,o;const s=performance.now();let u=delMinHeap(i.workElemIndicesByLength)%100,d=getAllowedNumbersforIndex(u,i);for(;1==d.length;)u=delMinHeap(i.workElemIndicesByLength)%100,d=getAllowedNumbersforIndex(u,i);if(0==d.length)continue;o.leastIndexIterationtimeTaken+=performance.now()-s,o.nflTT+=performance.now()-t;const a=performance.now();for(let n=0;n<d.length&&!o.solutionFound;n++){const t=d[n],r=performance.now(),s=copySudokuHeap(i,o);o.copytimetaken+=performance.now()-r;const a=performance.now();addInputSudokuHeap(s,u,t,1,o),o.AddInputTT+=performance.now()-a;const c=performance.now();for(;0!==s.toProcess.length;){const e=s.toProcess.pop();addInputSudokuHeap(s,e,getlog2for2Power(s.workElemArray[e]),1,o)}o.AddInputDirectLoopTT+=performance.now()-c;const p=performance.now();s.contradiction||e.push(s),o.skpushTT+=performance.now()-p}o.flTT+=performance.now()-a}return o.totalRunDFSTT=performance.now()-n,o.solutionFound=!1,o}function runDFSSudokuIterative(e){for(totalRunDFSTS=performance.now();0!=e.length&&!solutionFound;){nflTS=performance.now(),poppingTS=performance.now();const o=e.pop();if(poppingTT+=performance.now()-poppingTS,isSudokuDone(o)){totalRunDFSTT=performance.now()-totalRunDFSTS,solutionFound=!0,doFinishedProcessing(o,1,0);continue}leastIndexIterationTS=performance.now();o.workElemIndicesByLength;let n=0;for(let e=1;e<=9&&!n;e++)0!==o.workElemIndicesByLength[e].size&&(n=e);const t=o.workElemIndicesByLength[n].values().next().value,r=getAllowedNumbersforIndex(t,o);leastIndexIterationtimeTaken+=performance.now()-leastIndexIterationTS,nflTT+=performance.now()-nflTS,flTS=performance.now();for(let n=0;n<r.length&&!solutionFound;n++){const i=r[n];copyTimeStart=performance.now();const s=copySudoku(o);for(copytimetaken+=performance.now()-copyTimeStart,AddInputTS=performance.now(),addInputSudoku(s,t,i,1),AddInputTT+=performance.now()-AddInputTS,AddInputDirectLoopTS=performance.now();0!==s.toProcess.length;){const e=s.toProcess.pop();addInputSudoku(s,e,getlog2for2Power(s.workElemArray[e]),1)}AddInputDirectLoopTT+=performance.now()-AddInputDirectLoopTS,skpushTS=performance.now(),s.contradiction||e.push(s),skpushTT+=performance.now()-skpushTS}flTT+=performance.now()-flTS}solutionFound||doFinishedProcessing(runningSudoku,0,0)}function doFinishedProcessing(e,o,n,t=0,r=1){const i=document.getElementById("output-boxes");t||removeChildren(i);const s=document.createElement("div");s.innerHTML=n?"Solution:":"Solution could not be found",s.className="output-heading",i.appendChild(s);const u=document.createElement("div"),d=(performance.now()-o.startTime)/o.numIterations;let a=`<b>Finished ${o.numIterations} iterations. Average Time values below:</b><br>`;a+="Time Taken: "+d+"ms.<br>",console.log("iteration.numLoops=",o.numLoops),a+="Number of Guesses: "+(o.numLoops-1).toString()+".<br>",r&&(a+="totalRunDFSTT = "+o.totalRunDFSTT+"ms<br>",a+="non-for loop time taken = "+o.nflTT+"ms<br>",a+="for loop time taken = "+o.flTT+"ms<br><br><br>",a+="Non-forloop<br>",a+="least Index time taken = "+o.leastIndexIterationtimeTaken+"ms.<br>",a+="afterIsDoneTT = "+o.afterIsDoneTT+"ms<br>",a+="sudokuHolder popping time taken = "+o.poppingTT+"ms<br>",a+="<br>Forloop<br>",a+="copy time taken = "+o.copytimetaken+"ms.<br>",a+="AddInputTT time taken = "+o.AddInputTT+"ms.<br>",a+="DirectProcessing time taken = "+o.AddInputDirectLoopTT+"ms.<br>",a+="sudokuHolder push time taken = "+o.skpushTT+"ms.<br>",a+="<br>Other pages:Deepdive<br>",a+="copy function: total time taken = "+o.copyTotalTT+"ms.<br>",a+="copy function: initialize time taken = "+o.copyinitTT+"ms.<br>",a+="copy function: workElemArray time taken = "+o.copyworkElemArrayTT+"ms.<br>",a+="copy function: workElemIndicesByLength time taken = "+o.copyworkElemIndicesByLengthTT+"ms.<br>",a+="copy function: processed time taken = "+o.copyprocessedTT+"ms.<br>",a+="copy function: contradiction time taken = "+o.copycontradictionTT+"ms.<br>",a+="function updateheap time taken = "+o.updateWEIBLTimeTaken+"ms.<br>",a+="function updateAdditionForElems time taken = "+o.updateAdditionForElemsTimeTaken+"ms.<br>",a+="function: addInputSudoku time taken = "+o.addinputSudokuTT+"ms.<br>"),u.innerHTML=a,u.className="output-text",i.appendChild(u),console.log("Finished processing. Final sudoku = ",e,"Total Time Taken: "+d+"ms.<br>"),n&&drawSudoku(e,i,"div")}function createOptions(e){const o=e.clientX,n=e.clientY,t=e.target.id,r=getAllowedNumbersforIndex(t,Sudoku),i=document.getElementById("elem-options-holder");i.removeAttribute("onclick"),removeChildren(i);for(let e=0;e<r.length;e++){let o=document.createElement("div");o.className="sudokuElem-number",o.innerHTML=r[e],i.appendChild(o),o.setAttribute("onclick","setValueofSudokuElemfromNumChoice("+t.valueOf()+","+r[e].valueOf()+")")}i.classList.add("visibleOptionsList"),i.classList.remove("invisibleOptionsList"),i.setAttribute("style","left: "+o+"px; top: "+n+"px;"),sudokuElemOptionsShowing=!0}function removeChildren(e){for(;e.hasChildNodes();)e.removeChild(e.firstChild)}function setValueofSudokuElemfromNumChoice(e,o){document.getElementById("sudoku-box").getElementsByTagName("input")[e].value=o;const n=document.getElementById("elem-options-holder");n.removeAttribute("onclick"),removeChildren(n),n.classList.remove("visibleOptionsList"),n.classList.add("invisibleOptionsList"),checkInput(e,o.toString())}function clearOptionsDiv(){const e=document.getElementById("elem-options-holder");e.removeAttribute("onclick"),removeChildren(e),e.classList.remove("visibleOptionsList"),e.classList.add("invisibleOptionsList")}function drawSudoku(e,o,n){const t=document.createElement("div");t.className="gameBox-holder",o.appendChild(t);const r=document.createElement("div");r.className="gameBox",t.appendChild(r);for(let o=0;o<9;o++){const t=document.createElement("div");t.className="sudoku-box-row";for(let r=0;r<9;r++){const i=getAllowedNumbersforIndex(9*o+r,e).join(""),s=document.createElement(n);s.className="input-elem",0==o&&s.classList.add("outer-top"),2!=o&&5!=o||s.classList.add("inner-bottom"),3!=o&&6!=o||s.classList.add("inner-top"),8==o&&s.classList.add("outer-bottom"),0==r&&s.classList.add("outer-left"),2!=r&&5!=r||s.classList.add("inner-right"),3!=r&&6!=r||s.classList.add("inner-left"),8==r&&s.classList.add("outer-right"),"div"==n&&(s.innerHTML=i),t.appendChild(s)}r.appendChild(t)}}function toggleDisplay(e){divtoToggle=document.getElementById(e),divtoToggle.classList.contains("active")?(divtoToggle.classList.remove("active"),divtoToggle.classList.add("inactive"),divtoToggle.innerText.replace("Enter","Hide"),divtoToggle.innerText.replace("see","hide")):divtoToggle.classList.contains("inactive")&&(divtoToggle.classList.remove("inactive"),divtoToggle.classList.add("active"),divtoToggle.innerText.replace("Enter","Hide"),divtoToggle.innerText.replace("see","hide"))}function inputfromText(){console.log("input from text");const e=document.getElementById("sudokuTextInput").value,o=document.getElementById("sudoku-box").getElementsByTagName("input");console.log("textinput=",e);for(let n=0;n<Math.min(81,e.length);n++)o[n].value="","."!=e[n]&&(o[n].value=e[n],checkInput(n,e[n]));console.log("Sudoku = ",Sudoku)}function checkInput(e,o){logError("");const n=document.getElementById(e),t=getAllowedNumbersforIndex(e,Sudoku).toString().split(","),r=new Set(t),i=Number(e),s=Number(o);if(r.has(o))Sudoku=addInputSudokuHeap(Sudoku,i,s,0);else{let e;n.value="";const r=Sudoku.sudokuInputArray[i];0!=r?(Sudoku=deleteInputSudoku(Sudoku,i,r),console.log("Sudoku =",Sudoku),e='Your input: "'+o+'" lead to an Error! There was a previous value here: '+r+" which is now deleted."):e="Error! You have input value = '"+o+"'. The allowed values are: "+t.toString(),logError(e)}finalInputArray=Sudoku.sudokuInputArray}function addInputSudokuHeap(e,o,n,t=0,r=startIter){const i=performance.now(),s=powerofTwo(n-1);0==t&&(e.sudokuInputArray[o]=n);const[u,d,a]=Game.elemIndices[o],c=Game.indicesinRows[u],p=Game.indicesinCols[d],l=Game.indicesinBoxes[a];return updateAdditionForElemsHeap(e,c,o,s,r),updateAdditionForElemsHeap(e,p,o,s,r),updateAdditionForElemsHeap(e,l,o,s,r),e.contradiction||(e.workElemArray[o]=s,r.addinputSudokuTT+=performance.now()-i,e.numProcessed+=1),e}function addInputSudoku(e,o,n,t=0){addinputSudokuTS=performance.now();const r=powerofTwo(n-1);0==t&&(e.sudokuInputArray[o]=n);const[i,s,u]=Game.elemIndices[o],d=Game.indicesinRows[i],a=Game.indicesinCols[s],c=Game.indicesinBoxes[u];if(updateAdditionForElems(e,d,o,r),updateAdditionForElems(e,a,o,r),updateAdditionForElems(e,c,o,r),e.contradiction)return e;const p=e.workElemArray[o];e.workElemArray[o]=r;const l=bitCount(p);return e.workElemIndicesByLength[l].delete(o),addinputSudokuTT+=performance.now()-addinputSudokuTS,e.numProcessed+=1,e}function updateAdditionForElemsHeap(e,o,n,t,r=startIter){if(e.contradiction)return;const i=performance.now();for(let i=0;i<o.length;i++){const s=o[i];if(s!==n){const o=e.workElemArray[s],n=e.workElemArray[s]&~t;if(e.workElemArray[s]=n,0===n)return e.contradiction=!0,e;if(o!==n){const o=bitCount(n);1===o&&e.toProcess.push(s),updateHeap(e,s,o,n,r)}}}r.updateAdditionForElemsTimeTaken+=performance.now()-i}function updateAdditionForElems(e,o,n,t){if(!e.contradiction){updateAdditionForElemsTS=performance.now();for(let r=0;r<o.length;r++){const i=o[r];if(i!==n){const o=e.workElemArray[i],n=e.workElemArray[i]&~t;if(e.workElemArray[i]=n,0===n)return e.contradiction=!0,e;o!==n&&(isPowerOf2(n)&&e.toProcess.push(i),updateWEIBL(e,i,o,n))}}updateAdditionForElemsTimeTaken+=performance.now()-updateAdditionForElemsTS}}function deleteInputSudoku(e,o,n,t=0){const r=powerofTwo(n-1);let i=511;console.log("updatingInputWorkingVal=",i),0===t&&(e.sudokuInputArray[o]=0);const[s,u,d]=Game.elemIndices[o],a=Game.indicesinRows[s],c=Game.indicesinCols[u],p=Game.indicesinBoxes[d];i=updateDeletionforElems(e,a,o,r,i),i=updateDeletionforElems(e,c,o,r,i),i=updateDeletionforElems(e,p,o,r,i),e.workElemArray[o]=i;const l=bitCount(i);return e.workElemIndicesByLength[l].add(o),e.numProcessed-=1,e}function updateDeletionforElems(e,o,n,t,r){let i=r;for(let r=0;r<o.length;r++){const s=o[r];if(s!=n)if(finalInputArray[s])i&=~e.workElemArray[s];else{const o=Sudoku.workElemArray[s],n=Sudoku.workElemArray[s]|t;e.workElemArray[s]=n,o!=n&&updateWEIBL(e,s,o,n)}}return i}function updateHeap(e,o,n,t,r=startIter){const i=performance.now(),s=100*n+o;addToHeap(e.workElemIndicesByLength,s),r.updateWEIBLTimeTaken+=performance.now()-i}function updateWEIBL(e,o,n,t){updateWEIBLTimeStart=performance.now();const r=bitCount(n);e.workElemIndicesByLength[r].delete(o);const i=bitCount(t);e.workElemIndicesByLength[i].add(o),updateWEIBLTimeTaken+=performance.now()-updateWEIBLTimeStart}function logError(e){if(""==e){return void removeChildren(document.getElementById("output-errors"))}newError=document.createElement("div"),newError.className="output-error",newError.innerHTML=e,newErrorHeading=document.createElement("div"),newErrorHeading.className="output-heading",newErrorHeading.innerHTML="Error Message";const o=document.getElementById("output-errors");removeChildren(o),o.appendChild(newErrorHeading),o.appendChild(newError)}function isPowerOf2(e){return e&&!(e&e-1)}function getlog2for2Power(e){switch(e){case 1:return 1;case 2:return 2;case 4:return 3;case 8:return 4;case 16:return 5;case 32:return 6;case 64:return 7;case 128:return 8;case 256:return 9}}function bitCount(e){return 16843009*((e=(858993459&(e-=e>>1&1431655765))+(e>>2&858993459))+(e>>4)&252645135)>>24}function getAllowedNumbersforIndex(e,o){if(e<0)return[];let n=o.workElemArray[e];outNumbers=[];for(let e=0;e<9;e++)!0&n&&outNumbers.push(e+1),n>>=1;return outNumbers}function powerofTwo(e){return 1<<e}function isSudokuDone(e){if(solutionFound)return!0;let o=!0;for(let n=2;n<=9&&o;n++)0!==e.workElemIndicesByLength[n].size&&(o=!1);return o}function isSudokuDoneHeap(e,o){return!!(o.solutionFound||e.numProcessed>=81)}function addToHeap(e,o){e.push(o),heapifyUP(e,e.length-1)}function heapifyUP(e,o){if(o<=1)return;const n=~~(o/2);e[n]<=e[o]||(swap(e,n,o),heapifyUP(e,n))}function delMinHeap(e){if(e.length<=1)return-1;const o=e[1];return e[1]=e[e.length-1],e.pop(),heapifyDown(e,1),o}function heapifyDown(e,o){const n=2*o,t=2*o+1,r=e.length;if(r<n)return;if(r<t)return void(e[n]<e[o]&&swap(e,n,o));let i;i=e[n]<e[t]?n:t,e[i]<e[o]&&(swap(e,i,o),heapifyDown(e,i))}function swap(e,o,n){const t=e[o];e[o]=e[n],e[n]=t}finalInputArray=[],sudokuElemOptionsShowing=!1,buildSudoku();